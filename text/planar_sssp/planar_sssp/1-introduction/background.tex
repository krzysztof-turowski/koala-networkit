\section{Background and motivation}
The main goal of this thesis is to provide a clear and accessible presentation of the most important techniques and ideas behind the algorithms for the single source shortest path problem in planar graphs. By summarizing and comparing different approaches, we aim to give the reader a deeper understanding of how exploiting the structure of planar graphs can lead to significant algorithmic improvements.

Planar graphs possess several theoretical properties that are essential for designing efficient algorithms. For instance, planar graphs are sparse: the number of edges is $O(n)$, as follows from Euler's formula \cite{wiki}. Moreover, by the Planar Separator Theorem \cite{separatorT}, for any planar graph on $n$ vertices, it is possible to find a set of $O(\sqrt{n})$ vertices whose removal separates the graph into smaller, roughly balanced parts. These structural properties will be frequently used throughout this paper.

The single-source shortest path problem is one of the most fundamental and important problems in the family of planar graphs. The solutions presented in this paper may be used to improve the time complexity of various algorithms, such as finding feasible flows and matching in bipartite planar graphs.

The standard algorithm for finding shortest paths in weighted graphs is Dijkstra's algorithm. Its implementation using heap achieves time complexity of $O(n \log n)$ \cite{dijkstraBound}.

In this paper, we will present two algorithms for the single-source shortest path (SSSP) problem in planar graphs: the first is proposed by Greg Frederickson in 1986 \cite{frederickson}, achieving time complexity of $O(n \sqrt{\log n}) $, and the second is a simplified version of algorithm proposed by Monika Henzinger \cite{henzinger}, which achieves time complexity of $O(n \log \log n)$. Both of these algorithms are based on Dijkstra algorithm, but they additionally exploit properties of planar graphs to significantly reduce asymptotic running time. Currently, the best-known algorithm and also the one that achieves theoretical lower bound for finding the shortest path to every node in planar graphs is the SSSP algorithm from \cite{henzinger}, which runs in $O(n)$ time.

We will now briefly describe the Dijkstra algorithm to provide necessary intuition for understanding the proofs presented later in this paper. The main idea behind Dijkstra's algorithm serves as a foundation for more complex algorithms for planar graphs.

Dijkstra's algorithm computes the shortest path from a single source vertex $s$ to all other vertices in a weighted graph with non-negative edge weights. The algorithm maintains a set of vertices whose shortest distance from the source has already been determined, and for every other vertex $v$, it keeps track of the current best known distance $p(v)$ from $s$ to $v$.
Initially all vertices are open, $p(s) = 0$ and $p(v) = \infty$ for all $v \neq s$. Algorithm in each iteration closes the open vertex $v$ with the smallest $p(v)$ and relaxes all edges outgoing from $v$. That is, for every neighbor $w$ of $v$, the algorithm updates $p(w)$ if a shorter path from $s$ to $w$ via $v$ is found.

The distances $p(v)$ can be maintained in a heap, which allows for $O(\log n)$ time per update. Since there are $O(n)$ heap updates, and each edge is relaxed at most once, the total running time is $O(n \log n)$ \cite{dijkstraBound}.

One approach to reducing the asymptotic running time of shortest path algorithms is to minimize the maximum number of nodes present in the heap at any given time. This means that a preprocessing phase is necessary to identify this subset of vertices a heap will be used on. How can we exploit properties of planar graphs to achieve this goal? The key idea shared by both of the algorithms presented in this paper is to partition the graph into appropriate sized regions during the prepossessing phase. In Chapter 2, we will describe the specific properties that such a division must have in order to take advantage of the structure of planar graphs, as well as how to construct this partition efficiently. Once the partitioning is completed, the algorithm must carefully coordinate heap updates between the regions to avoid increasing the total number of heap operations. In Chapters 3 and 4, we will explain the approaches taken by each of the two algorithms in detail.

